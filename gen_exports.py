# ! /usr/bin/env python3
# -*- coding: utf-8 -`-
"""
Code generation script for class methods
to be exported as public API
"""
import argparse
import ast
import astor
import difflib
import os
import yapf.yapflib.yapf_api as formatter

SOURCE_TREE = './trio/_core'
YAPF_STYLE = './.style.yapf'

IMPORTS = """# ***********************************************************
# ******* WARNING: AUTOGENERATED! ALL EDITS WILL BE LOST ******
# *************************************************************
from ._run import GLOBAL_RUN_CONTEXT, _NO_SEND
from ._ki import LOCALS_KEY_KI_PROTECTION_ENABLED

    
"""

TEMPLATE = """locals()[LOCALS_KEY_KI_PROTECTION_ENABLED] = True
try:
    return GLOBAL_RUN_CONTEXT.{}.{}
except AttributeError:
    raise RuntimeError('must be called from async context')
"""


def is_function(node):
    """Check if the AST node is either a function
    or an async function
    """
    return isinstance(node, ast.FunctionDef) \
           or isinstance(node, ast.AsyncFunctionDef)


def is_public(node):
    """Check if the AST node has a _public decorator
    """
    return is_function(node) \
           and node.decorator_list \
           and isinstance(node.decorator_list[-1], ast.Name) \
           and node.decorator_list[-1].id == '_public'


def get_public_methods(tree):
    """ Return a list of methods marked as public.
    The function walks the given tree and extracts
    all objects that are functions and have a
    doc string that starts with PUBLIC
    """
    methods = []
    for node in ast.walk(tree):
        for child in ast.iter_child_nodes(node):
            if is_public(child):
                child.parent = node
                child.module_file = tree.module_file
                child.module_path = tree.module_path
                methods.append(child)
    return methods


def get_module_trees_by_dir(source_dir):
    """ Converts a list of modules into ast module objects
    """
    mod_files = astor.code_to_ast.find_py_files(source_dir)
    modules = []
    for mod_file in mod_files:
        if not mod_file[1].startswith('_public'):
            module = astor.code_to_ast.parse_file(os.path.join(*mod_file))
            module.module_path = mod_file[0]
            module.module_file = mod_file[1]
            modules.append(module)
    return modules


def get_export_modules_by_dir(source_dir):
    """Return all modules in the given directory
    and its sub directories which contain methods
    marked to be public as AST module trees
    """
    export_modules = []
    modules = get_module_trees_by_dir(source_dir)

    for module in modules:
        methods = get_public_methods(module)
        if methods:
            export_modules.append(module)
    return export_modules


def get_doc_string(func):
    """ Returns the doc string of a function
    or an empty sting if none
    """
    doc = func.body[0]
    if isinstance(doc, ast.Expr):
        if hasattr(doc, 'value'):
            if hasattr(doc.value, 's'):
                return doc.value.s
    return ""


def create_passthrough_args(funcdef):
    """ Create a pass through argument list
    Every default argument value is
    replaced by its argument corresponding
    argument name
    """
    call_args = []
    for arg in funcdef.args.args:
        call_args.append(arg.arg)
    for _, arg in zip(funcdef.args.defaults[::-1], funcdef.args.args[::-1]):
        call_args.remove(arg.arg)
        call_args.append(arg.arg + "=" + arg.arg)
    if funcdef.args.vararg:
        call_args.append("*" + funcdef.args.vararg.arg)
    for arg in funcdef.args.kwonlyargs:
        call_args.append(arg.arg + "=" + arg.arg)
    if funcdef.args.kwarg:
        call_args.append("**" + funcdef.args.kwarg.arg)
    return "({})".format(", ".join(call_args))


def gen_source():
    """ Create a source file for each module that contains
    a method that is exported as public API. For each method
    a wrapper is created and added to its corresponding module.
    """

    source = dict()
    imports = IMPORTS
    # Create a module for each os and the common code
    for module in get_export_modules_by_dir(SOURCE_TREE):
        source[module.module_file] = [imports]

    # Get all modules we have classes with methods to export in the directory path
    trees = get_export_modules_by_dir(SOURCE_TREE)

    # Get all methods we want to export
    methods = [meth for tree in trees for meth in get_public_methods(tree)]

    # Loop over all methods and create the source
    for method in methods:
        if method.parent.name == 'Runner':
            ctx = 'runner'
        else:
            ctx = "runner.io_manager"
        # Remove self from arguments
        method.args.args.pop(0)

        # Remove decorators
        method.decorator_list = []

        # Create pass through arguments
        new_args = create_passthrough_args(method)

        # Remove method body
        del method.body[1:]

        # Create export function body
        template = TEMPLATE.format(ctx, method.name + new_args)

        # Assemble function definition arguments and body
        ast_method = ast.parse(template)
        method.body.extend(ast_method.body)
        snippet = astor.to_source(method).replace('async ', '')

        # Append the snippet to the corresponding module
        source[method.module_file].append(snippet)

    formatted_source = dict()
    # Fix formatting so yapf won't complain
    for pub_file in source.keys():
        formatted_source[pub_file] = formatter.FormatCode(
            '\n'.join(source[pub_file]), style_config=YAPF_STYLE
        )
    return formatted_source


if __name__ == '__main__':
    sources = gen_source()

    parser = argparse.ArgumentParser(
        description='Generate python code for public api wrappers'
    )
    parser.add_argument(
        '--path',
        '-p',
        default=SOURCE_TREE,
        type=str,
        const=SOURCE_TREE,
        nargs='?',
        help='create new code at the path (default: {}'.format(SOURCE_TREE)
    )
    parser.add_argument(
        '--test',
        '-t',
        action='store_true',
        help='test if code is still up to date'
    )

    args = parser.parse_args()
    if args.test:
        print(args.test)
    if args.path:
        print(args.path)
    else:
        print(parser.usage)
